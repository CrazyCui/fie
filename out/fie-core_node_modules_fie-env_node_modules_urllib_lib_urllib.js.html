<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>共享FIE Source: fie-core/node_modules/fie-env/node_modules/urllib/lib/urllib.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.cosmo.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">共享FIE</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="fie-config.html">fie-config</a></li><li><a href="fie-fs.html">fie-fs</a></li><li><a href="fie-home.html">fie-home</a></li><li><a href="fie-log.html">fie-log</a></li><li><a href="fie-report.html">fie-report</a></li><li><a href="fie-user.html">fie-user</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="fie-fs.module_copy-directory.html">fie-fs.copy-directory</a></li><li><a href="fie-fs.module_copy-tpl.html">fie-fs.copy-tpl</a></li><li><a href="fie-fs.module_rewrite-file.html">fie-fs.rewrite-file</a></li><li><a href="module-fie-config.html">fie-config</a></li><li><a href="module-fie-home.html">fie-home</a></li><li><a href="module-fie-log.html">fie-log</a></li><li><a href="module-fie-report.html">fie-report</a></li><li><a href="module-fie-user.html">fie-user</a></li><li><a href="module-jodid25519.html">jodid25519</a></li><li><a href="module-jodid25519_core.html">jodid25519/core</a></li><li><a href="module-jodid25519_curve255.html">jodid25519/curve255</a></li><li><a href="module-jodid25519_dh.html">jodid25519/dh</a></li><li><a href="module-jodid25519_eddsa.html">jodid25519/eddsa</a></li><li><a href="module-jodid25519_utils.html">jodid25519/utils</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="-_.html">_</a></li><li><a href="FormData.html">FormData</a></li><li><a href="Promise.html">Promise</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html"></a></li><li><a href="global.html#abort">abort</a></li><li><a href="global.html#accessLogDate">accessLogDate</a></li><li><a href="global.html#addOptionType">addOptionType</a></li><li><a href="global.html#address">address</a></li><li><a href="global.html#amdefine">amdefine</a></li><li><a href="global.html#argumentsToArray">argumentsToArray</a></li><li><a href="global.html#ArrayIndex">ArrayIndex</a></li><li><a href="global.html#Arrayish">Arrayish</a></li><li><a href="global.html#arrayProto">arrayProto</a></li><li><a href="global.html#arrayToPromise">arrayToPromise</a></li><li><a href="global.html#ascending">ascending</a></li><li><a href="global.html#assert">assert</a></li><li><a href="global.html#async">async</a></li><li><a href="global.html#asyncTag">asyncTag</a></li><li><a href="global.html#authorization">authorization</a></li><li><a href="global.html#base64decode">base64decode</a></li><li><a href="global.html#base64encode">base64encode</a></li><li><a href="global.html#bashCompletionFromOptions">bashCompletionFromOptions</a></li><li><a href="global.html#bashCompletionSpecFromOptions">bashCompletionSpecFromOptions</a></li><li><a href="global.html#boolTag">boolTag</a></li><li><a href="global.html#Buffer">Buffer</a></li><li><a href="global.html#bytes">bytes</a></li><li><a href="global.html#camelcase">camelcase</a></li><li><a href="global.html#canonicalizeHeaders">canonicalizeHeaders</a></li><li><a href="global.html#canonicalizeResource">canonicalizeResource</a></li><li><a href="global.html#charset">charset</a></li><li><a href="global.html#clean">clean</a></li><li><a href="global.html#CLONE_DEEP_FLAG">CLONE_DEEP_FLAG</a></li><li><a href="global.html#CLONE_SYMBOLS_FLAG">CLONE_SYMBOLS_FLAG</a></li><li><a href="global.html#co">co</a></li><li><a href="global.html#coerce">coerce</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#Command">Command</a></li><li><a href="global.html#config">config</a></li><li><a href="global.html#contentType">contentType</a></li><li><a href="global.html#convert">convert</a></li><li><a href="global.html#copy">copy</a></li><li><a href="global.html#Copy">Copy</a></li><li><a href="global.html#CORE_ERROR_TEXT">CORE_ERROR_TEXT</a></li><li><a href="global.html#createWritableStdioStream">createWritableStdioStream</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#datestruct">datestruct</a></li><li><a href="global.html#debug">debug</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#decodeBodyByCharset">decodeBodyByCharset</a></li><li><a href="global.html#decodeURIComponent">decodeURIComponent</a></li><li><a href="global.html#DEFAULT_TRUNC_LENGTH">DEFAULT_TRUNC_LENGTH</a></li><li><a href="global.html#defer">defer</a></li><li><a href="global.html#define">define</a></li><li><a href="global.html#Delegator">Delegator</a></li><li><a href="global.html#deprecate">deprecate</a></li><li><a href="global.html#descending">descending</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#dig">dig</a></li><li><a href="global.html#dir">dir</a></li><li><a href="global.html#disable">disable</a></li><li><a href="global.html#Domain">Domain</a></li><li><a href="global.html#domExcTag">domExcTag</a></li><li><a href="global.html#eifelerRegelAppliesToNumber">eifelerRegelAppliesToNumber</a></li><li><a href="global.html#enable">enable</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodeURIComponent">encodeURIComponent</a></li><li><a href="global.html#ensureLength">ensureLength</a></li><li><a href="global.html#escape">escape</a></li><li><a href="global.html#escapeHtml">escapeHtml</a></li><li><a href="global.html#event">event</a></li><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#expectCommaSeparator">expectCommaSeparator</a></li><li><a href="global.html#extension">extension</a></li><li><a href="global.html#fd">fd</a></li><li><a href="global.html#fiePkg">fiePkg</a></li><li><a href="global.html#findAccessibleSync">findAccessibleSync</a></li><li><a href="global.html#finisher">finisher</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#Foo">Foo</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#formatters">formatters</a></li><li><a href="global.html#freeExports">freeExports</a></li><li><a href="global.html#freeModule">freeModule</a></li><li><a href="global.html#freeParseFloat">freeParseFloat</a></li><li><a href="global.html#freeParseInt">freeParseInt</a></li><li><a href="global.html#fs">fs</a></li><li><a href="global.html#FUNC_ERROR_TEXT">FUNC_ERROR_TEXT</a></li><li><a href="global.html#funcProto">funcProto</a></li><li><a href="global.html#funcToString">funcToString</a></li><li><a href="global.html#genify">genify</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getCommonData">getCommonData</a></li><li><a href="global.html#getIP">getIP</a></li><li><a href="global.html#getIPv6">getIPv6</a></li><li><a href="global.html#getLength">getLength</a></li><li><a href="global.html#getPadding">getPadding</a></li><li><a href="global.html#getParamNames">getParamNames</a></li><li><a href="global.html#getProjectEnv">getProjectEnv</a></li><li><a href="global.html#gyp">gyp</a></li><li><a href="global.html#has">has</a></li><li><a href="global.html#hash">hash</a></li><li><a href="global.html#hasOwnProperty">hasOwnProperty</a></li><li><a href="global.html#hmac">hmac</a></li><li><a href="global.html#hmacSha1">hmacSha1</a></li><li><a href="global.html#https">https</a></li><li><a href="global.html#humanReadableArgName">humanReadableArgName</a></li><li><a href="global.html#idCounter">idCounter</a></li><li><a href="global.html#inc">inc</a></li><li><a href="global.html#INFINITY">INFINITY</a></li><li><a href="global.html#inherits">inherits</a></li><li><a href="global.html#inspect">inspect</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isGenerator">isGenerator</a></li><li><a href="global.html#isGeneratorFunction">isGeneratorFunction</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isPromise">isPromise</a></li><li><a href="global.html#isSafeNumberString">isSafeNumberString</a></li><li><a href="global.html#iterate">iterate</a></li><li><a href="global.html#keys">keys</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadImplementation">loadImplementation</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#logDate">logDate</a></li><li><a href="global.html#lookup">lookup</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mapTag">mapTag</a></li><li><a href="global.html#MAX_ARRAY_LENGTH">MAX_ARRAY_LENGTH</a></li><li><a href="global.html#MAX_LENGTH">MAX_LENGTH</a></li><li><a href="global.html#MAX_SAFE_INTEGER">MAX_SAFE_INTEGER</a></li><li><a href="global.html#md5">md5</a></li><li><a href="global.html#moduleExports">moduleExports</a></li><li><a href="global.html#names">names</a></li><li><a href="global.html#NAN">NAN</a></li><li><a href="global.html#noop">noop</a></li><li><a href="global.html#notDefined">notDefined</a></li><li><a href="global.html#numberTag">numberTag</a></li><li><a href="global.html#objectCtorString">objectCtorString</a></li><li><a href="global.html#objectProto">objectProto</a></li><li><a href="global.html#objectTag">objectTag</a></li><li><a href="global.html#objectToPromise">objectToPromise</a></li><li><a href="global.html#Option">Option</a></li><li><a href="global.html#optionKeyFromName">optionKeyFromName</a></li><li><a href="global.html#osName">osName</a></li><li><a href="global.html#outFieHelpInfo">outFieHelpInfo</a></li><li><a href="global.html#outputHelpIfNecessary">outputHelpIfNecessary</a></li><li><a href="global.html#pad">pad</a></li><li><a href="global.html#parallel">parallel</a></li><li><a href="global.html#paramRegExp">paramRegExp</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#parseDate">parseDate</a></li><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#path">path</a></li><li><a href="global.html#PathArray">PathArray</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#prevColor">prevColor</a></li><li><a href="global.html#prevTime">prevTime</a></li><li><a href="global.html#prog">prog</a></li><li><a href="global.html#propertyIsEnumerable">propertyIsEnumerable</a></li><li><a href="global.html#punycode">punycode</a></li><li><a href="global.html#pureModuleName">pureModuleName</a></li><li><a href="global.html#qescRegExp">qescRegExp</a></li><li><a href="global.html#queryStringToSign">queryStringToSign</a></li><li><a href="global.html#quoteRegExp">quoteRegExp</a></li><li><a href="global.html#random">random</a></li><li><a href="global.html#randomSlice">randomSlice</a></li><li><a href="global.html#read">read</a></li><li><a href="global.html#read1">read1</a></li><li><a href="global.html#read2">read2</a></li><li><a href="global.html#ReadableAsyncKit">ReadableAsyncKit</a></li><li><a href="global.html#ReadableParallel">ReadableParallel</a></li><li><a href="global.html#ReadableSerial">ReadableSerial</a></li><li><a href="global.html#ReadableSerialOrdered">ReadableSerialOrdered</a></li><li><a href="global.html#reComboMark">reComboMark</a></li><li><a href="global.html#reEmptyStringLeading">reEmptyStringLeading</a></li><li><a href="global.html#reEscapedHtml">reEscapedHtml</a></li><li><a href="global.html#reEsTemplate">reEsTemplate</a></li><li><a href="global.html#reFlags">reFlags</a></li><li><a href="global.html#reIsBadHex">reIsBadHex</a></li><li><a href="global.html#reIsBinary">reIsBinary</a></li><li><a href="global.html#reIsOctal">reIsOctal</a></li><li><a href="global.html#reLatin">reLatin</a></li><li><a href="global.html#reNoMatch">reNoMatch</a></li><li><a href="global.html#replace">replace</a></li><li><a href="global.html#request">request</a></li><li><a href="global.html#reRegExpChar">reRegExpChar</a></li><li><a href="global.html#reTrim">reTrim</a></li><li><a href="global.html#reTrimEnd">reTrimEnd</a></li><li><a href="global.html#reTrimStart">reTrimStart</a></li><li><a href="global.html#reUnescapedHtml">reUnescapedHtml</a></li><li><a href="global.html#reUnescapedString">reUnescapedString</a></li><li><a href="global.html#rm">rm</a></li><li><a href="global.html#rsCombo">rsCombo</a></li><li><a href="global.html#rsComboMarksRange">rsComboMarksRange</a></li><li><a href="global.html#runCommand">runCommand</a></li><li><a href="global.html#runFunction">runFunction</a></li><li><a href="global.html#runJob">runJob</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#selectColor">selectColor</a></li><li><a href="global.html#serial">serial</a></li><li><a href="global.html#serialOrdered">serialOrdered</a></li><li><a href="global.html#setEnv">setEnv</a></li><li><a href="global.html#setLength">setLength</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#sha1">sha1</a></li><li><a href="global.html#sha256">sha256</a></li><li><a href="global.html#shallowCopy">shallowCopy</a></li><li><a href="global.html#shouldPreferGlobalPromise">shouldPreferGlobalPromise</a></li><li><a href="global.html#sign">sign</a></li><li><a href="global.html#signQuery">signQuery</a></li><li><a href="global.html#slice">slice</a></li><li><a href="global.html#spawn">spawn</a></li><li><a href="global.html#spliceOne">spliceOne</a></li><li><a href="global.html#split">split</a></li><li><a href="global.html#state">state</a></li><li><a href="global.html#status">status</a></li><li><a href="global.html#streamer">streamer</a></li><li><a href="global.html#strictJSONParse">strictJSONParse</a></li><li><a href="global.html#stringTag">stringTag</a></li><li><a href="global.html#stringToSign">stringToSign</a></li><li><a href="global.html#Symbol">Symbol</a></li><li><a href="global.html#symbolTag">symbolTag</a></li><li><a href="global.html#symIterator">symIterator</a></li><li><a href="global.html#symlinkPaths">symlinkPaths</a></li><li><a href="global.html#synopsisFromOpt">synopsisFromOpt</a></li><li><a href="global.html#terminator">terminator</a></li><li><a href="global.html#TEXT_DATA_TYPES">TEXT_DATA_TYPES</a></li><li><a href="global.html#textwrap">textwrap</a></li><li><a href="global.html#thenify">thenify</a></li><li><a href="global.html#thenifyAll">thenifyAll</a></li><li><a href="global.html#thread">thread</a></li><li><a href="global.html#thunkify">thunkify</a></li><li><a href="global.html#thunkToPromise">thunkToPromise</a></li><li><a href="global.html#TIMEOUT">TIMEOUT</a></li><li><a href="global.html#timestamp">timestamp</a></li><li><a href="global.html#toPromise">toPromise</a></li><li><a href="global.html#toSafeNumber">toSafeNumber</a></li><li><a href="global.html#try">try</a></li><li><a href="global.html#tryAutoDetect">tryAutoDetect</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#typeRegExp">typeRegExp</a></li><li><a href="global.html#useColors">useColors</a></li><li><a href="global.html#userInfoGetter">userInfoGetter</a></li><li><a href="global.html#util">util</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#weakMapTag">weakMapTag</a></li><li><a href="global.html#weakSetTag">weakSetTag</a></li><li><a href="global.html#withCallback">withCallback</a></li><li><a href="global.html#WRAP_ARY_FLAG">WRAP_ARY_FLAG</a></li><li><a href="global.html#WRAP_BIND_FLAG">WRAP_BIND_FLAG</a></li><li><a href="global.html#WRAP_CURRY_FLAG">WRAP_CURRY_FLAG</a></li><li><a href="global.html#WRAP_CURRY_RIGHT_FLAG">WRAP_CURRY_RIGHT_FLAG</a></li><li><a href="global.html#WRAP_FLIP_FLAG">WRAP_FLIP_FLAG</a></li><li><a href="global.html#WRAP_PARTIAL_FLAG">WRAP_PARTIAL_FLAG</a></li><li><a href="global.html#WRAP_PARTIAL_RIGHT_FLAG">WRAP_PARTIAL_RIGHT_FLAG</a></li><li><a href="global.html#WRAP_REARG_FLAG">WRAP_REARG_FLAG</a></li><li><a href="global.html#wrapCallback">wrapCallback</a></li><li><a href="global.html#wrapIterator">wrapIterator</a></li><li><a href="global.html#wrapIteratorCallback">wrapIteratorCallback</a></li><li><a href="global.html#YYYYMMDD">YYYYMMDD</a></li><li><a href="global.html#YYYYMMDDHHmmss">YYYYMMDDHHmmss</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: fie-core/node_modules/fie-env/node_modules/urllib/lib/urllib.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">'use strict';

var debug = require('debug')('urllib');
var http = require('http');
var https = require('https');
var urlutil = require('url');
var util = require('util');
var qs = require('querystring');
var zlib = require('zlib');
var ua = require('default-user-agent');
var digestAuthHeader = require('digest-header');
var util = require('util');
var EventEmitter = require('events').EventEmitter;
var ms = require('humanize-ms');
var statuses = require('statuses');
var contentTypeParser = require('content-type');

var _Promise;
var _iconv;

var pkg = require('../package.json');

var USER_AGENT = exports.USER_AGENT = ua('node-urllib', pkg.version);

// change Agent.maxSockets to 1000
exports.agent = new http.Agent();
exports.agent.maxSockets = 1000;

exports.httpsAgent = new https.Agent();
exports.httpsAgent.maxSockets = 1000;

/**
 * The default request timeout(in milliseconds).
 * @type {Number}
 * @const
 */

exports.TIMEOUT = ms('5s');
exports.TIMEOUTS = [ms('5s'), ms('5s')];

var REQUEST_ID = 0;
var MAX_VALUE = Math.pow(2, 31) - 10;
var isOldVersionNode = /^v0\.10\.\d+$/.test(process.version);

/**
 * support data types
 * will auto decode response body
 * @type {Array}
 */
var TEXT_DATA_TYPES = [
  'json',
  'text'
];

var PROTO_RE = /^https?:\/\//i;

/**
 * Handle all http request, both http and https support well.
 *
 * @example
 *
 * // GET http://httptest.cnodejs.net
 * urllib.request('http://httptest.cnodejs.net/test/get', function(err, data, res) {});
 * // POST http://httptest.cnodejs.net
 * var args = { type: 'post', data: { foo: 'bar' } };
 * urllib.request('http://httptest.cnodejs.net/test/post', args, function(err, data, res) {});
 *
 * @param {String|Object} url
 * @param {Object} [args], optional
 *   - {Object} [data]: request data, will auto be query stringify.
 *   - {String|Buffer} [content]: optional, if set content, `data` will ignore.
 *   - {ReadStream} [stream]: read stream to sent.
 *   - {WriteStream} [writeStream]: writable stream to save response data.
 *       If you use this, callback's data should be null.
 *       We will just `pipe(ws, {end: true})`.
 *   - {consumeWriteStream} [true]: consume the writeStream, invoke the callback after writeStream close.
 *   - {String} [method]: optional, could be GET | POST | DELETE | PUT, default is GET
 *   - {String} [contentType]: optional, request data type, could be `json`, default is undefined
 *   - {String} [dataType]: optional, response data type, could be `text` or `json`, default is buffer
 *   - {Boolean} [fixJSONCtlChars]: optional, fix the control characters (U+0000 through U+001F)
 *       before JSON parse response. Default is `false`
 *   - {Object} [headers]: optional, request headers
 *   - {Number|Array} [timeout]: request timeout(in milliseconds), default is `exports.TIMEOUTS containing connect timeout and response timeout`
 *   - {Agent} [agent]: optional, http agent. Set `false` if you does not use agent.
 *   - {Agent} [httpsAgent]: optional, https agent. Set `false` if you does not use agent.
 *   - {String} [auth]: Basic authentication i.e. 'user:password' to compute an Authorization header.
 *   - {String} [digestAuth]: Digest authentication i.e. 'user:password' to compute an Authorization header.
 *   - {String|Buffer|Array} [ca]: An array of strings or Buffers of trusted certificates.
 *       If this is omitted several well known "root" CAs will be used, like VeriSign.
 *       These are used to authorize connections.
 *       Notes: This is necessary only if the server uses the self-signed certificate
 *   - {Boolean} [rejectUnauthorized]: If true, the server certificate is verified against the list of supplied CAs.
 *       An 'error' event is emitted if verification fails. Default: true.
 *   - {String|Buffer} [pfx]: A string or Buffer containing the private key,
 *       certificate and CA certs of the server in PFX or PKCS12 format.
 *   - {String|Buffer} [key]: A string or Buffer containing the private key of the client in PEM format.
 *       Notes: This is necessary only if using the client certificate authentication
 *   - {String|Buffer} [cert]: A string or Buffer containing the certificate key of the client in PEM format.
 *       Notes: This is necessary only if using the client certificate authentication
 *   - {String} [passphrase]: A string of passphrase for the private key or pfx.
 *   - {String} [ciphers]: A string describing the ciphers to use or exclude.
 *   - {String} [secureProtocol]: The SSL method to use, e.g. SSLv3_method to force SSL version 3.
 *       The possible values depend on your installation of OpenSSL and are defined in the constant SSL_METHODS.
 *   - {Boolean} [followRedirect]: Follow HTTP 3xx responses as redirects. defaults to false.
 *   - {Number} [maxRedirects]: The maximum number of redirects to follow, defaults to 10.
 *   - {Function(from, to)} [formatRedirectUrl]: Format the redirect url by your self. Default is `url.resolve(from, to)`
 *   - {Function(options)} [beforeRequest]: Before request hook, you can change every thing here.
 *   - {Boolean} [streaming]: let you get the res object when request connected, default is `false`. alias `customResponse`
 *   - {Boolean} [gzip]: Accept gzip response content and auto decode it, default is `false`.
 *   - {Boolean} [timing]: Enable timing or not, default is `false`.
 *   - {Function} [lookup]: Custom DNS lookup function, default is `dns.lookup`.
 *       Require node >= 4.0.0 and only work on `http` protocol.
 * @param {Function} [callback], callback(error, data, res). If missing callback, will return a promise object.
 * @return {HttpRequest} req object.
 * @api public
 */
exports.request = function request(url, args, callback) {
  // request(url, callback)
  if (arguments.length === 2 &amp;&amp; typeof args === 'function') {
    callback = args;
    args = null;
  }
  if (typeof callback === 'function') {
    return exports.requestWithCallback(url, args, callback);
  }

  // Promise
  if (!_Promise) {
    _Promise = require('any-promise');
  }
  return new _Promise(function (resolve, reject) {
    exports.requestWithCallback(url, args, makeCallback(resolve, reject));
  });
};

// alias to curl
exports.curl = exports.request;

function makeCallback(resolve, reject) {
  return function (err, data, res) {
    if (err) {
      return reject(err);
    }
    resolve({
      data: data,
      status: res.statusCode,
      headers: res.headers,
      res: res
    });
  };
}

// yield urllib.requestThunk(url, args)
exports.requestThunk = function requestThunk(url, args) {
  return function (callback) {
    exports.requestWithCallback(url, args, function (err, data, res) {
      if (err) {
        return callback(err);
      }
      callback(null, {
        data: data,
        status: res.statusCode,
        headers: res.headers,
        res: res
      });
    });
  };
};

exports.requestWithCallback = function requestWithCallback(url, args, callback) {
  // requestWithCallback(url, callback)
  if (!url || (typeof url !== 'string' &amp;&amp; typeof url !== 'object')) {
    var msg = util.format('expect request url to be a string or a http request options, but got %j', url);
    throw new Error(msg);
  }

  if (arguments.length === 2 &amp;&amp; typeof args === 'function') {
    callback = args;
    args = null;
  }

  args = args || {};
  if (REQUEST_ID >= MAX_VALUE) {
    REQUEST_ID = 0;
  }
  var reqId = ++REQUEST_ID;

  args.requestUrls = args.requestUrls || [];

  if (args.emitter) {
    args.emitter.emit('request', {
      requestId: reqId,
      url: url,
      args: args,
      ctx: args.ctx,
    });
  }

  args.timeout = args.timeout || exports.TIMEOUTS;
  args.maxRedirects = args.maxRedirects || 10;
  args.streaming = args.streaming || args.customResponse;
  var requestStartTime = Date.now();
  var parsedUrl;

  if (typeof url === 'string') {
    if (!PROTO_RE.test(url)) {
      // Support `request('www.server.com')`
      url = 'http://' + url;
    }
    parsedUrl = urlutil.parse(url);
  } else {
    parsedUrl = url;
  }

  var method = (args.type || args.method || parsedUrl.method || 'GET').toUpperCase();
  var port = parsedUrl.port || 80;
  var httplib = http;
  var agent = getAgent(args.agent, exports.agent);
  var fixJSONCtlChars = !!args.fixJSONCtlChars;

  if (parsedUrl.protocol === 'https:') {
    httplib = https;
    agent = getAgent(args.httpsAgent, exports.httpsAgent);

    if (!parsedUrl.port) {
      port = 443;
    }
  }

  var options = {
    host: parsedUrl.hostname || parsedUrl.host || 'localhost',
    path: parsedUrl.path || '/',
    method: method,
    port: port,
    agent: agent,
    headers: args.headers || {},
    // default is dns.lookup
    // https://github.com/nodejs/node/blob/master/lib/net.js#L986
    // custom dnslookup require node >= 4.0.0
    // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952
    lookup: args.lookup,
  };

  var sslNames = [
    'pfx',
    'key',
    'passphrase',
    'cert',
    'ca',
    'ciphers',
    'rejectUnauthorized',
    'secureProtocol',
    'secureOptions',
  ];
  for (var i = 0; i &lt; sslNames.length; i++) {
    var name = sslNames[i];
    if (args.hasOwnProperty(name)) {
      options[name] = args[name];
    }
  }

  // don't check ssl
  if (options.rejectUnauthorized === false &amp;&amp; !options.hasOwnProperty('secureOptions')) {
    options.secureOptions = require('constants').SSL_OP_NO_TLSv1_2;
  }

  var auth = args.auth || parsedUrl.auth;
  if (auth) {
    options.auth = auth;
  }

  var body = args.content || args.data;
  var isReadAction = method === 'GET' || method === 'HEAD';
  if (!args.content) {
    if (body &amp;&amp; !(typeof body === 'string' || Buffer.isBuffer(body))) {
      if (isReadAction) {
        // read: GET, HEAD, use query string
        body = qs.stringify(body);
      } else {
        var contentType = options.headers['Content-Type'] || options.headers['content-type'];
        // auto add application/x-www-form-urlencoded when using urlencode form request
        if (!contentType) {
          if (args.contentType === 'json') {
            contentType = 'application/json';
          } else {
            contentType = 'application/x-www-form-urlencoded';
          }
          options.headers['Content-Type'] = contentType;
        }

        if (parseContentType(contentType).type === 'application/json') {
          body = JSON.stringify(body);
        } else {
          // 'application/x-www-form-urlencoded'
          body = qs.stringify(body);
        }
      }
    }
  }

  // if it's a GET or HEAD request, data should be sent as query string
  if (isReadAction &amp;&amp; body) {
    options.path += (parsedUrl.query ? '&amp;' : '?') + body;
    body = null;
  }

  var requestSize = 0;
  if (body) {
    var length = body.length;
    if (!Buffer.isBuffer(body)) {
      length = Buffer.byteLength(body);
    }
    requestSize = options.headers['Content-Length'] = length;
  }

  if (args.dataType === 'json') {
    options.headers.Accept = 'application/json';
  }

  if (typeof args.beforeRequest === 'function') {
    // you can use this hook to change every thing.
    args.beforeRequest(options);
  }
  var connectTimer = null;
  var responseTimer = null;
  var __err = null;
  var connected = false; // socket connected or not
  var keepAliveSocket = false; // request with keepalive socket
  var responseSize = 0;
  var statusCode = -1;
  var responseAborted = false;
  var remoteAddress = '';
  var remotePort = '';
  var timing = null;
  if (args.timing) {
    timing = {
      // socket assigned
      queuing: 0,
      // dns lookup time
      dnslookup: 0,
      // socket connected
      connected: 0,
      // request sent
      requestSent: 0,
      // Time to first byte (TTFB)
      waiting: 0,
      contentDownload: 0,
    };
  }

  function cancelConnectTimer() {
    if (connectTimer) {
      clearTimeout(connectTimer);
      connectTimer = null;
    }
  }
  function cancelResponseTimer() {
    if (responseTimer) {
      clearTimeout(responseTimer);
      responseTimer = null;
    }
  }

  function done(err, data, res) {
    cancelResponseTimer();
    if (!callback) {
      console.warn('[urllib:warn] [%s] [worker:%s] %s %s callback twice!!!',
        Date(), process.pid, options.method, url);
      // https://github.com/node-modules/urllib/pull/30
      if (err) {
        console.warn('[urllib:warn] [%s] [worker:%s] %s: %s\nstack: %s',
          Date(), process.pid, err.name, err.message, err.stack);
      }
      return;
    }
    var cb = callback;
    callback = null;
    var headers = {};
    if (res) {
      statusCode = res.statusCode;
      headers = res.headers;
    }

    // handle digest auth
    if (statusCode === 401 &amp;&amp; headers['www-authenticate']
        &amp;&amp; (!args.headers || !args.headers.Authorization) &amp;&amp; args.digestAuth) {
      var authenticate = headers['www-authenticate'];
      if (authenticate.indexOf('Digest ') >= 0) {
        debug('Request#%d %s: got digest auth header WWW-Authenticate: %s', reqId, url, authenticate);
        args.headers = args.headers || {};
        args.headers.Authorization = digestAuthHeader(options.method, options.path, authenticate, args.digestAuth);
        debug('Request#%d %s: auth with digest header: %s', reqId, url, args.headers.Authorization);
        if (res.headers['set-cookie']) {
          args.headers.Cookie = res.headers['set-cookie'].join(';');
        }
        return exports.requestWithCallback(url, args, cb);
      }
    }

    var requestUseTime = Date.now() - requestStartTime;
    if (timing) {
      timing.contentDownload = requestUseTime;
    }

    debug('[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j',
      requestUseTime, responseSize, statusCode, options.method, options.host, options.path,
      keepAliveSocket, timing);

    var response = {
      status: statusCode,
      statusCode: statusCode,
      headers: headers,
      size: responseSize,
      aborted: responseAborted,
      rt: requestUseTime,
      keepAliveSocket: keepAliveSocket,
      data: data,
      requestUrls: args.requestUrls,
      timing: timing,
      remoteAddress: remoteAddress,
      remotePort: remotePort,
    };

    if (err) {
      var agentStatus = '';
      if (agent &amp;&amp; typeof agent.getCurrentStatus === 'function') {
        // add current agent status to error message for logging and debug
        agentStatus = ', agent status: ' + JSON.stringify(agent.getCurrentStatus());
      }
      err.message += ', ' + options.method + ' ' + url + ' ' + statusCode
        + ' (connected: ' + connected + ', keepalive socket: ' + keepAliveSocket + agentStatus + ')'
        + '\nheaders: ' + JSON.stringify(headers);
      err.data = data;
      err.path = options.path;
      err.status = statusCode;
      err.headers = headers;
      err.res = response;
    }

    cb(err, data, args.streaming ? res : response);

    if (args.emitter) {
      args.emitter.emit('response', {
        requestId: reqId,
        error: err,
        ctx: args.ctx,
        req: {
          url: url,
          socket: req &amp;&amp; req.connection,
          options: options,
          size: requestSize,
        },
        res: response
      });
    }
  }

  function handleRedirect(res) {
    var err = null;
    if (args.followRedirect &amp;&amp; statuses.redirect[res.statusCode]) {  // handle redirect
      args._followRedirectCount = (args._followRedirectCount || 0) + 1;
      var location = res.headers.location;
      if (!location) {
        err = new Error('Got statusCode ' + res.statusCode + ' but cannot resolve next location from headers');
        err.name = 'FollowRedirectError';
      } else if (args._followRedirectCount > args.maxRedirects) {
        err = new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + url);
        err.name = 'MaxRedirectError';
      } else {
        var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url, location) : urlutil.resolve(url, location);
        debug('Request#%d %s: `redirected` from %s to %s', reqId, options.path, url, newUrl);
        // make sure timer stop
        cancelResponseTimer();
        // should clean up headers.Host on `location: http://other-domain/url`
        if (args.headers &amp;&amp; args.headers.Host &amp;&amp; PROTO_RE.test(location)) {
          args.headers.Host = null;
        }
        // avoid done will be execute in the future change.
        var cb = callback;
        callback = null;
        exports.requestWithCallback(newUrl, args, cb);
        return {
          redirect: true,
          error: null
        };
      }
    }
    return {
      redirect: false,
      error: err
    };
  }

  // set user-agent
  if (!options.headers['User-Agent'] &amp;&amp; !options.headers['user-agent']) {
    options.headers['User-Agent'] = USER_AGENT;
  }

  if (args.gzip) {
    if (!options.headers['Accept-Encoding'] &amp;&amp; !options.headers['accept-encoding']) {
      options.headers['Accept-Encoding'] = 'gzip';
    }
  }

  function decodeContent(res, body, cb) {
    var encoding = res.headers['content-encoding'];
    if (body.length === 0) {
      return cb(null, body, encoding);
    }

    if (!encoding || encoding.toLowerCase() !== 'gzip') {
      return cb(null, body, encoding);
    }

    debug('gunzip %d length body', body.length);
    zlib.gunzip(body, cb);
  }

  var writeStream = args.writeStream;

  debug('Request#%d %s %s with headers %j, options.path: %s',
    reqId, method, url, options.headers, options.path);

  args.requestUrls.push(url);

  function onResponse(res) {
    if (timing) {
      timing.waiting = Date.now() - requestStartTime;
    }
    debug('Request#%d %s `req response` event emit: status %d, headers: %j',
      reqId, url, res.statusCode, res.headers);

    if (args.streaming) {
      var result = handleRedirect(res);
      if (result.redirect) {
        res.resume();
        return;
      }
      if (result.error) {
        res.resume();
        return done(result.error, null, res);
      }

      return done(null, null, res);
    }

    if (writeStream) {
      // If there's a writable stream to recieve the response data, just pipe the
      // response stream to that writable stream and call the callback when it has
      // finished writing.
      //
      // NOTE that when the response stream `res` emits an 'end' event it just
      // means that it has finished piping data to another stream. In the
      // meanwhile that writable stream may still writing data to the disk until
      // it emits a 'close' event.
      //
      // That means that we should not apply callback until the 'close' of the
      // writable stream is emited.
      //
      // See also:
      // - https://github.com/TBEDP/urllib/commit/959ac3365821e0e028c231a5e8efca6af410eabb
      // - http://nodejs.org/api/stream.html#stream_event_end
      // - http://nodejs.org/api/stream.html#stream_event_close_1
      var result = handleRedirect(res);
      if (result.redirect) {
        res.resume();
        return;
      }
      if (result.error) {
        res.resume();
        // end ths stream first
        writeStream.end();
        return done(result.error, null, res);
      }
      // you can set consumeWriteStream false that only wait response end
      if (args.consumeWriteStream === false) {
        res.on('end', done.bind(null, null, null, res));
      } else {
        writeStream.on('close', done.bind(null, null, null, res));
      }
      return res.pipe(writeStream);
    }

    // Otherwise, just concat those buffers.
    //
    // NOTE that the `chunk` is not a String but a Buffer. It means that if
    // you simply concat two chunk with `+` you're actually converting both
    // Buffers into Strings before concating them. It'll cause problems when
    // dealing with multi-byte characters.
    //
    // The solution is to store each chunk in an array and concat them with
    // 'buffer-concat' when all chunks is recieved.
    //
    // See also:
    // http://cnodejs.org/topic/4faf65852e8fb5bc65113403

    var chunks = [];

    res.on('data', function (chunk) {
      debug('Request#%d %s: `res data` event emit, size %d', reqId, url, chunk.length);
      responseSize += chunk.length;
      chunks.push(chunk);
    });

    // res.on('close', function () {
    //   debug('Request#%d %s: `res close` event emit, total size %d',
    //     reqId, url, responseSize);
    // });

    // res.on('error', function () {
    //   debug('Request#%d %s: `res error` event emit, total size %d',
    //     reqId, url, responseSize);
    // });

    res.on('aborted', function () {
      responseAborted = true;
      debug('Request#%d %s: `res aborted` event emit, total size %d',
        reqId, url, responseSize);
    });

    res.on('end', function () {
      var body = Buffer.concat(chunks, responseSize);
      debug('Request#%d %s: `res end` event emit, total size %d, _dumped: %s',
        reqId, url, responseSize, res._dumped);

      if (__err) {
        // req.abort() after `res data` event emit.
        return done(__err, body, res);
      }

      var result = handleRedirect(res);
      if (result.error) {
        return done(result.error, body, res);
      }
      if (result.redirect) {
        return;
      }

      decodeContent(res, body, function (err, data, encoding) {
        if (err) {
          return done(err, body, res);
        }
        // if body not decode, dont touch it
        if (!encoding &amp;&amp; TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {
          // try to decode charset
          try {
            data = decodeBodyByCharset(data, res);
          } catch (e) {
            debug('decodeBodyByCharset error: %s', e);
            // if error, dont touch it
            return done(null, data, res);
          }

          if (args.dataType === 'json') {
            if (responseSize === 0) {
              data = null;
            } else {
              var r = parseJSON(data, fixJSONCtlChars);
              if (r.error) {
                err = r.error;
              } else {
                data = r.data;
              }
            }
          }
        }

        if (responseAborted) {
          // err = new Error('Remote socket was terminated before `response.end()` was called');
          // err.name = 'RemoteSocketClosedError';
          debug('Request#%d %s: Remote socket was terminated before `response.end()` was called', reqId, url);
        }

        done(err, data, res);
      });
    });
  }

  var connectTimeout, responseTimeout;
  if (Array.isArray(args.timeout)) {
    connectTimeout = ms(args.timeout[0]);
    responseTimeout = ms(args.timeout[1]);
  } else {  // set both timeout equal
    connectTimeout = responseTimeout = ms(args.timeout);
  }
  debug('ConnectTimeout: %d, ResponseTimeout: %d', connectTimeout, responseTimeout);

  function startConnectTimer() {
    debug('Connect timer ticking, timeout: %d', connectTimeout);
    connectTimer = setTimeout(function () {
      connectTimer = null;
      if (statusCode === -1) {
        statusCode = -2;
      }
      var msg = 'Connect timeout for ' + connectTimeout + 'ms';
      var errorName = 'ConnectionTimeoutError';
      if (!req.socket) {
        errorName = 'SocketAssignTimeoutError';
        msg += ', working sockets is full';
      }
      __err = new Error(msg);
      __err.name = errorName;
      __err.requestId = reqId;
      debug('ConnectTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);
      abortRequest();
    }, connectTimeout);
  }

  function startResposneTimer() {
    debug('Response timer ticking, timeout: %d', responseTimeout);
    responseTimer = setTimeout(function () {
      responseTimer = null;
      var msg = 'Response timeout for ' + responseTimeout + 'ms';
      var errorName = 'ResponseTimeoutError';
      __err = new Error(msg);
      __err.name = errorName;
      __err.requestId = reqId;
      debug('ResponseTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);
      abortRequest();
    }, responseTimeout);
  }

  var req;
  // request headers checker will throw error
  try {
    req = httplib.request(options, onResponse);
  } catch (err) {
    return done(err);
  }
  // start connect timer just after `request` return
  startConnectTimer();

  function abortRequest() {
    debug('Request#%d %s abort, connected: %s', reqId, url, connected);
    // it wont case error event when req haven't been assigned a socket yet.
    if (!req.socket) {
      __err.noSocket = true;
      done(__err);
    }
    req.abort();
  }

  if (timing) {
    // request sent
    req.on('finish', function() {
      timing.requestSent = Date.now() - requestStartTime;
    });
  }

  req.once('socket', function (socket) {
    if (timing) {
      // socket queuing time
      timing.queuing = Date.now() - requestStartTime;
    }

    // https://github.com/nodejs/node/blob/master/lib/net.js#L377
    // https://github.com/nodejs/node/blob/v0.10.40-release/lib/net.js#L352
    // should use socket.socket on 0.10.x
    if (isOldVersionNode &amp;&amp; socket.socket) {
      socket = socket.socket;
    }

    var readyState = socket.readyState;
    if (readyState === 'opening') {
      socket.once('lookup', function(err, ip, addressType) {
        debug('Request#%d %s lookup: %s, %s, %s', reqId, url, err, ip, addressType);
        if (timing) {
          timing.dnslookup = Date.now() - requestStartTime;
        }
        if (ip) {
          remoteAddress = ip;
        }
      });
      socket.once('connect', function() {
        if (timing) {
          // socket connected
          timing.connected = Date.now() - requestStartTime;
        }

        // cancel socket timer at first and start tick for TTFB
        cancelConnectTimer();
        startResposneTimer();

        debug('Request#%d %s new socket connected', reqId, url);
        connected = true;
        if (!remoteAddress) {
          remoteAddress = socket.remoteAddress;
        }
        remotePort = socket.remotePort;
      });
      return;
    }

    debug('Request#%d %s reuse socket connected, readyState: %s', reqId, url, readyState);
    connected = true;
    keepAliveSocket = true;
    if (!remoteAddress) {
      remoteAddress = socket.remoteAddress;
    }
    remotePort = socket.remotePort;

    // reuse socket, timer should be canceled.
    cancelConnectTimer();
    startResposneTimer();
  });

  req.on('error', function (err) {
    if (err.name === 'Error') {
      err.name = connected ? 'ResponseError' : 'RequestError';
    }
    err.message += ' (req "error")';
    debug('Request#%d %s `req error` event emit, %s: %s', reqId, url, err.name, err.message);
    done(__err || err);
  });

  if (writeStream) {
    writeStream.once('error', function (err) {
      err.message += ' (writeStream "error")';
      __err = err;
      debug('Request#%d %s `writeStream error` event emit, %s: %s', reqId, url, err.name, err.message);
      abortRequest();
    });
  }

  if (args.stream) {
    args.stream.pipe(req);
    args.stream.once('error', function (err) {
      err.message += ' (stream "error")';
      __err = err;
      debug('Request#%d %s `readStream error` event emit, %s: %s', reqId, url, err.name, err.message);
      abortRequest();
    });
  } else {
    req.end(body);
  }

  req.requestId = reqId;
  return req;
};

var JSONCtlCharsMap = {
  '"': '\\"',       // \u0022
  '\\': '\\\\',     // \u005c
  '\b': '\\b',      // \u0008
  '\f': '\\f',      // \u000c
  '\n': '\\n',      // \u000a
  '\r': '\\r',      // \u000d
  '\t': '\\t'       // \u0009
};
var JSONCtlCharsRE = /[\u0000-\u001F\u005C]/g;

function _replaceOneChar(c) {
  return JSONCtlCharsMap[c] || '\\u' + (c.charCodeAt(0) + 0x10000).toString(16).substr(1);
}

function replaceJSONCtlChars(str) {
  return str.replace(JSONCtlCharsRE, _replaceOneChar);
}

function parseJSON(data, fixJSONCtlChars) {
  var result = {
    error: null,
    data: null
  };
  if (fixJSONCtlChars) {
    // https://github.com/node-modules/urllib/pull/77
    // remote the control characters (U+0000 through U+001F)
    data = replaceJSONCtlChars(data);
  }
  try {
    result.data = JSON.parse(data);
  } catch (err) {
    if (err.name === 'SyntaxError') {
      err.name = 'JSONResponseFormatError';
    }
    if (data.length > 1024) {
      // show 0~512 ... -512~end data
      err.message += ' (data json format: ' +
        JSON.stringify(data.slice(0, 512)) + ' ...skip... ' + JSON.stringify(data.slice(data.length - 512)) + ')';
    } else {
      err.message += ' (data json format: ' + JSON.stringify(data) + ')';
    }
    result.error = err;
  }
  return result;
}


function HttpClient(options) {
  EventEmitter.call(this);
  options = options || {};

  if (options.agent !== undefined) {
    this.agent = options.agent;
    this.hasCustomAgent = true;
  } else {
    this.agent = exports.agent;
    this.hasCustomAgent = false;
  }

  if (options.httpsAgent !== undefined) {
    this.httpsAgent = options.httpsAgent;
    this.hasCustomHttpsAgent = true;
  } else {
    this.httpsAgent = exports.httpsAgent;
    this.hasCustomHttpsAgent = false;
  }
}
util.inherits(HttpClient, EventEmitter);

HttpClient.prototype.request = HttpClient.prototype.curl = function (url, args, callback) {
  if (typeof args === 'function') {
    callback = args;
    args = null;
  }
  args = args || {};
  args.emitter = this;
  args.agent = getAgent(args.agent, this.agent);
  args.httpsAgent = getAgent(args.httpsAgent, this.httpsAgent);
  return exports.request(url, args, callback);
};

HttpClient.prototype.requestThunk = function (url, args) {
  args = args || {};
  args.emitter = this;
  args.agent = getAgent(args.agent, this.agent);
  args.httpsAgent = getAgent(args.httpsAgent, this.httpsAgent);
  return exports.requestThunk(url, args);
};

exports.HttpClient = HttpClient;

exports.create = function (options) {
  return new HttpClient(options);
};

/**
 * decode response body by parse `content-type`'s charset
 * @param {Buffer} data
 * @param {Http(s)Response} res
 * @return {String}
 */
function decodeBodyByCharset(data, res) {
  var type = res.headers['content-type'];
  if (!type) {
    return data.toString();
  }

  var type = parseContentType(type);
  var charset = type.parameters.charset || 'utf-8';

  if (!Buffer.isEncoding(charset)) {
    if (!_iconv) {
      _iconv = require('iconv-lite');
    }
    return _iconv.decode(data, charset);
  }

  return data.toString(charset);
}

function getAgent(agent, defaultAgent) {
  return agent === undefined ? defaultAgent : agent;
}

function parseContentType(str) {
  try {
    return contentTypeParser.parse(str);
  } catch (err) {
    // ignore content-type error, tread as default
    return { parameters: {} };
  }
}
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	©2016 FIE-Team   |   旺旺交流群 1455030646
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a>
	
		on Fri Nov 18th 2016
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
